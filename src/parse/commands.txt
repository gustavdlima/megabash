Parsing

Na hora de parsear o comando precisamos considerar o que tem antes e depois do token, pois assim
podemos assumir se a sintaxe do token está correta.

Num comando simples, temos as seguintes opções:
    0. cat file                         [cmd] [arquivo]
    1. echo "oi"                        [cmd] [opção]
    2. ls -l file                       [cmd] [opção] [arquivo]
    3. ls -l -a -m file                 [cmd] [opção] [opção] [opção] [arquivo]
    4. ls -lam file                     [cmd] [opção] [arquivo]
    5. cat file > file                  [cmd] [opção] [output] [arquivo]
    6. cat file > file2 ls              [cmd] [opção] [output] [arquivo]                      {erro}
    7. ls -l > file > file1             [cmd] [opção] [output] [arquivo] [output] [arquivo] 
    8. cat file > file2 < file3         [cmd] [opção] [output] [arquivo] [input] [arquivo]    {ignora o input}
    9. ls -l < file                     [cmd] [opção] [input] [arquivo]                       {ignora o input}
    10. ls -l < file ls                 [cmd] [opção] [input] [arquivo] [cmd]
    11. ls -l < file > file             [cmd] [opção] [input] [arquivo] [output] [arquivo]      {ignora o input}
    12. cat Makefile < file < file1     [cmd] [opção] [input] [arquivo] [input] [arquivo]
    13. > file ls -l > file1            [output] [arquivo] [comando] [opção] [output] [arquivo]
    14. > file ls > file2               [output] [arquivo] [cmd] [output] [arquivo]
    15. > file ls > file2 ls > file3    [output] [arquivo] [cmd] [output] [arquivo] [cmd] [output] [arquivo]
    16. < file tr 'a' 'p'               [input] [arquivo] [cmd]
    17. < file ls > file1


Estrutura de dados para lidar com o parsing

typedef struct s_commands{
	int					type; execve
	char				*cmd; cat
	char				**content; cat file
	typedef struct s_redirect{
        int         type;
        char        *content; a gente trata como string ou uma array de string
        t_redirect  *next;
    }
	struct s_commands	*next;
}				t_commands;

cat file.txt >> echo 'oi' tr i $ | tr i ! | ls
 ls -l > file > file1 
< file tr 'a' 'b' | cat file > file > file > file
cat FILE < makefile cat echo 

dps de >> e > a gente considera como arquivo
dps de < file a gente aguardar um comando

PSEUDOCÓDIGO

cat file.txt >> echo 'oi' tr i $ | tr i ! | ls

1. pegar a lista de token e colocar num loop; ou pode ser um loop infinito
2. a gente vai verificar qual o tipo do token;
3. se for do tipo word, a gente chama uma função que vai ter as verificações pra o caso word:
    3.1 caso word:
            3.1.1 a gente adiciona no *cmd e verifica o que tem depois do token;
            3.1.2 se tiver algo depois e for diferente de uma operação, a gente concatena com o cmd no content 
                  ate ter uma operacao;
                3.1.2.1 se for >> ou > a gente adiciona na struct de redirect o tipo e o que vir depois da operacao 
                        em content. (se for uma word seguida de outra word depois da operacao, consideramos como comando);
                3.1.2.2 se for < a gente adiciona na struct de redirect o tipo e o que vier depois no conteudo,
                        mas depois do que vier dps de < a gente considera como comando e faz um outro NO;
            3.1.3 vai verificando ate ter um pipe (lembrar de salvar a quantidade de pipe na variavel global)
4. se for uma operacao, a gente chama uma funcao que vai ter as verificacoes para o caso operacao
    4.1 caso operacao:
            4.1.1 se for < a gente adiciona na struct de redirect o tipo e o que vier depois no conteudo,
                        mas depois do que vier dps de < a gente considera como comando e faz um outro NO;
            4.1.2 se for >> ou > a gente adiciona na struct de redirect o tipo e o que vir depois da operacao 
                  em content. (se for uma word seguida de outra word depois da operacao, consideramos como comando)

se o loop for desse jeito:

while (token)
{
    token = funcao que trata tudo ate o pipe e retorna no pipe;
    if (token == |)
        pipe++;
        token = token->next;
    continue ;
}
